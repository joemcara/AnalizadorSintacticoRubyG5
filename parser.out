Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    ASSIGNDECREMENT
    ASSIGNINCREMENT
    ASSIGNMENT
    BREAK
    CASE
    CHOMP
    CLASS
    CLOSEDBRACKET
    DOT
    ELSE
    ELSIF
    EQUALS
    FOR
    GETS
    GREATEROREQUALS
    GREATERTHAN
    IN
    LESSTHAN
    OPENBRACKET
    PUTS
    STRING
    THEN
    TO_F
    TO_I

Grammar

Rule 0     S' -> instruction
Rule 1     instruction -> PRINT ID
Rule 2     instruction -> DEF ID LPAREN parameters RPAREN END
Rule 3     instruction -> DEF ID LPAREN RPAREN END
Rule 4     instruction -> IF condition
Rule 5     instruction -> WHILE condition END
Rule 6     parameters -> ID
Rule 7     parameters -> ID COMMA ID
Rule 8     arithmetic -> PLUS
Rule 9     arithmetic -> MINUS
Rule 10    arithmetic -> POWER
Rule 11    arithmetic -> MULTIPLICATION
Rule 12    arithmetic -> DIVISION
Rule 13    operations -> dataType arithmetic dataType
Rule 14    operations -> arithmetic dataType
Rule 15    condition -> TRUE
Rule 16    condition -> FALSE
Rule 17    dataType -> FLOAT
Rule 18    dataType -> INTEGER

Terminals, with rules where they appear

AND                  : 
ASSIGNDECREMENT      : 
ASSIGNINCREMENT      : 
ASSIGNMENT           : 
BREAK                : 
CASE                 : 
CHOMP                : 
CLASS                : 
CLOSEDBRACKET        : 
COMMA                : 7
DEF                  : 2 3
DIVISION             : 12
DOT                  : 
ELSE                 : 
ELSIF                : 
END                  : 2 3 5
EQUALS               : 
FALSE                : 16
FLOAT                : 17
FOR                  : 
GETS                 : 
GREATEROREQUALS      : 
GREATERTHAN          : 
ID                   : 1 2 3 6 7 7
IF                   : 4
IN                   : 
INTEGER              : 18
LESSTHAN             : 
LPAREN               : 2 3
MINUS                : 9
MULTIPLICATION       : 11
OPENBRACKET          : 
PLUS                 : 8
POWER                : 10
PRINT                : 1
PUTS                 : 
RPAREN               : 2 3
STRING               : 
THEN                 : 
TO_F                 : 
TO_I                 : 
TRUE                 : 15
WHILE                : 5
error                : 

Nonterminals, with rules where they appear

arithmetic           : 13 14
condition            : 4 5
dataType             : 13 13 14
instruction          : 0
operations           : 
parameters           : 2

Parsing method: LALR

state 0

    (0) S' -> . instruction
    (1) instruction -> . PRINT ID
    (2) instruction -> . DEF ID LPAREN parameters RPAREN END
    (3) instruction -> . DEF ID LPAREN RPAREN END
    (4) instruction -> . IF condition
    (5) instruction -> . WHILE condition END

    PRINT           shift and go to state 2
    DEF             shift and go to state 3
    IF              shift and go to state 4
    WHILE           shift and go to state 5

    instruction                    shift and go to state 1

state 1

    (0) S' -> instruction .



state 2

    (1) instruction -> PRINT . ID

    ID              shift and go to state 6


state 3

    (2) instruction -> DEF . ID LPAREN parameters RPAREN END
    (3) instruction -> DEF . ID LPAREN RPAREN END

    ID              shift and go to state 7


state 4

    (4) instruction -> IF . condition
    (15) condition -> . TRUE
    (16) condition -> . FALSE

    TRUE            shift and go to state 9
    FALSE           shift and go to state 10

    condition                      shift and go to state 8

state 5

    (5) instruction -> WHILE . condition END
    (15) condition -> . TRUE
    (16) condition -> . FALSE

    TRUE            shift and go to state 9
    FALSE           shift and go to state 10

    condition                      shift and go to state 11

state 6

    (1) instruction -> PRINT ID .

    $end            reduce using rule 1 (instruction -> PRINT ID .)


state 7

    (2) instruction -> DEF ID . LPAREN parameters RPAREN END
    (3) instruction -> DEF ID . LPAREN RPAREN END

    LPAREN          shift and go to state 12


state 8

    (4) instruction -> IF condition .

    $end            reduce using rule 4 (instruction -> IF condition .)


state 9

    (15) condition -> TRUE .

    $end            reduce using rule 15 (condition -> TRUE .)
    END             reduce using rule 15 (condition -> TRUE .)


state 10

    (16) condition -> FALSE .

    $end            reduce using rule 16 (condition -> FALSE .)
    END             reduce using rule 16 (condition -> FALSE .)


state 11

    (5) instruction -> WHILE condition . END

    END             shift and go to state 13


state 12

    (2) instruction -> DEF ID LPAREN . parameters RPAREN END
    (3) instruction -> DEF ID LPAREN . RPAREN END
    (6) parameters -> . ID
    (7) parameters -> . ID COMMA ID

    RPAREN          shift and go to state 16
    ID              shift and go to state 14

    parameters                     shift and go to state 15

state 13

    (5) instruction -> WHILE condition END .

    $end            reduce using rule 5 (instruction -> WHILE condition END .)


state 14

    (6) parameters -> ID .
    (7) parameters -> ID . COMMA ID

    RPAREN          reduce using rule 6 (parameters -> ID .)
    COMMA           shift and go to state 17


state 15

    (2) instruction -> DEF ID LPAREN parameters . RPAREN END

    RPAREN          shift and go to state 18


state 16

    (3) instruction -> DEF ID LPAREN RPAREN . END

    END             shift and go to state 19


state 17

    (7) parameters -> ID COMMA . ID

    ID              shift and go to state 20


state 18

    (2) instruction -> DEF ID LPAREN parameters RPAREN . END

    END             shift and go to state 21


state 19

    (3) instruction -> DEF ID LPAREN RPAREN END .

    $end            reduce using rule 3 (instruction -> DEF ID LPAREN RPAREN END .)


state 20

    (7) parameters -> ID COMMA ID .

    RPAREN          reduce using rule 7 (parameters -> ID COMMA ID .)


state 21

    (2) instruction -> DEF ID LPAREN parameters RPAREN END .

    $end            reduce using rule 2 (instruction -> DEF ID LPAREN parameters RPAREN END .)

