Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    ASSIGNDECREMENT
    ASSIGNINCREMENT
    BREAK
    CASE
    CHOMP
    CLASS
    CLOSEDBRACKET
    DIVISION
    DOT
    ELSE
    ELSIF
    EQUALS
    FOR
    GETS
    GREATEROREQUALS
    GREATERTHAN
    IN
    LESSTHAN
    MINUS
    MULTIPLICATION
    OPENBRACKET
    PLUS
    POWER
    PRINT
    PUTS
    STRING
    THEN
    TO_F
    TO_I
    WHILE

Grammar

Rule 0     S' -> instruction
Rule 1     instruction -> ID ASSIGNMENT dataType
Rule 2     instruction -> DEF ID LPAREN parameters RPAREN END
Rule 3     instruction -> DEF ID LPAREN RPAREN END
Rule 4     parameters -> ID
Rule 5     parameters -> ID COMMA ID
Rule 6     instructionConditional -> IF LPAREN condition RPAREN
Rule 7     condition -> TRUE
Rule 8     condition -> FALSE
Rule 9     dataType -> FLOAT
Rule 10    dataType -> INTEGER
Rule 11    dataType -> TRUE
Rule 12    dataType -> FALSE

Terminals, with rules where they appear

AND                  : 
ASSIGNDECREMENT      : 
ASSIGNINCREMENT      : 
ASSIGNMENT           : 1
BREAK                : 
CASE                 : 
CHOMP                : 
CLASS                : 
CLOSEDBRACKET        : 
COMMA                : 5
DEF                  : 2 3
DIVISION             : 
DOT                  : 
ELSE                 : 
ELSIF                : 
END                  : 2 3
EQUALS               : 
FALSE                : 8 12
FLOAT                : 9
FOR                  : 
GETS                 : 
GREATEROREQUALS      : 
GREATERTHAN          : 
ID                   : 1 2 3 4 5 5
IF                   : 6
IN                   : 
INTEGER              : 10
LESSTHAN             : 
LPAREN               : 2 3 6
MINUS                : 
MULTIPLICATION       : 
OPENBRACKET          : 
PLUS                 : 
POWER                : 
PRINT                : 
PUTS                 : 
RPAREN               : 2 3 6
STRING               : 
THEN                 : 
TO_F                 : 
TO_I                 : 
TRUE                 : 7 11
WHILE                : 
error                : 

Nonterminals, with rules where they appear

condition            : 6
dataType             : 1
instruction          : 0
instructionConditional : 
parameters           : 2

Parsing method: LALR

state 0

    (0) S' -> . instruction
    (1) instruction -> . ID ASSIGNMENT dataType
    (2) instruction -> . DEF ID LPAREN parameters RPAREN END
    (3) instruction -> . DEF ID LPAREN RPAREN END

    ID              shift and go to state 2
    DEF             shift and go to state 3

    instruction                    shift and go to state 1

state 1

    (0) S' -> instruction .



state 2

    (1) instruction -> ID . ASSIGNMENT dataType

    ASSIGNMENT      shift and go to state 4


state 3

    (2) instruction -> DEF . ID LPAREN parameters RPAREN END
    (3) instruction -> DEF . ID LPAREN RPAREN END

    ID              shift and go to state 5


state 4

    (1) instruction -> ID ASSIGNMENT . dataType
    (9) dataType -> . FLOAT
    (10) dataType -> . INTEGER
    (11) dataType -> . TRUE
    (12) dataType -> . FALSE

    FLOAT           shift and go to state 7
    INTEGER         shift and go to state 8
    TRUE            shift and go to state 9
    FALSE           shift and go to state 10

    dataType                       shift and go to state 6

state 5

    (2) instruction -> DEF ID . LPAREN parameters RPAREN END
    (3) instruction -> DEF ID . LPAREN RPAREN END

    LPAREN          shift and go to state 11


state 6

    (1) instruction -> ID ASSIGNMENT dataType .

    $end            reduce using rule 1 (instruction -> ID ASSIGNMENT dataType .)


state 7

    (9) dataType -> FLOAT .

    $end            reduce using rule 9 (dataType -> FLOAT .)


state 8

    (10) dataType -> INTEGER .

    $end            reduce using rule 10 (dataType -> INTEGER .)


state 9

    (11) dataType -> TRUE .

    $end            reduce using rule 11 (dataType -> TRUE .)


state 10

    (12) dataType -> FALSE .

    $end            reduce using rule 12 (dataType -> FALSE .)


state 11

    (2) instruction -> DEF ID LPAREN . parameters RPAREN END
    (3) instruction -> DEF ID LPAREN . RPAREN END
    (4) parameters -> . ID
    (5) parameters -> . ID COMMA ID

    RPAREN          shift and go to state 14
    ID              shift and go to state 12

    parameters                     shift and go to state 13

state 12

    (4) parameters -> ID .
    (5) parameters -> ID . COMMA ID

    RPAREN          reduce using rule 4 (parameters -> ID .)
    COMMA           shift and go to state 15


state 13

    (2) instruction -> DEF ID LPAREN parameters . RPAREN END

    RPAREN          shift and go to state 16


state 14

    (3) instruction -> DEF ID LPAREN RPAREN . END

    END             shift and go to state 17


state 15

    (5) parameters -> ID COMMA . ID

    ID              shift and go to state 18


state 16

    (2) instruction -> DEF ID LPAREN parameters RPAREN . END

    END             shift and go to state 19


state 17

    (3) instruction -> DEF ID LPAREN RPAREN END .

    $end            reduce using rule 3 (instruction -> DEF ID LPAREN RPAREN END .)


state 18

    (5) parameters -> ID COMMA ID .

    RPAREN          reduce using rule 5 (parameters -> ID COMMA ID .)


state 19

    (2) instruction -> DEF ID LPAREN parameters RPAREN END .

    $end            reduce using rule 2 (instruction -> DEF ID LPAREN parameters RPAREN END .)

